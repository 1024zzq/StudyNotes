# 系统设计&场景题

## * 如何解决大文件上传问题?

如果你的项目涉及到文件上传的话,面试官很可能会问你这个问题.

我们先看第一个场景:大文件上传中途,突然失败  试想一个,你想上传一个5g的视频,上传进度到99%的时候,特么的,突然网络断了,这个时候,你发现自己竟然需要重新上传.我就问你抓狂不? 有没有解决办法呢?

答案就是:分片上传!
什么是分片上传呢

简单来说,我们只需要先将文件切分成多个文件分片,然后再上传这些小的文件分片.

**前端发送了所有文件分片之后,服务端再将这些文件分片进行合并即可.**



前端可以通过Blob.slice()方法来对文件进行切割(File 对象是继承Blob对象的,因此File对象也有slice()方法).
后端可以RandomAccessFile类帮助我们合并文件分片



# JAVA

## * JavaIO模型常见面试题总结

根据冯.诺依曼结构,计算机结构分为5大部分:运算器、控制器、存储器、输入设备、输出设备.

输入设备(比如键盘)和输出设备(比如显示屏)都属于外部设备. 网卡、硬盘这种既可以属于输入设备,也可以属于输出设备.
输入设备向计算机输入数据,输出设备接收计算机输出的数据.

从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。

***

**我们再先从应用程序的角度来解读一下 I/O。**

根据大学里学到的操作系统相关的知识：为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 **用户空间（User space） 和 内核 空间（Kernel space）** 

像我们平常运行的应用程序都是运行在用户空间，**只有内核空间才能进行系统态级别的资源有关的操作**，比如如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。
并且，用户空间的程序不能直接访问内核空间。

当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。
因此，用户进程想要执行 IO 操作的话，必须通过 **系统调用** 来间接访问内核空间

我们在平常开发过程中接触最多的就是 **磁盘 IO（读写文件）** 和 **网络 IO（网络请求和响应）**

**从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就 是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。**

当应用程序发起 I/O 调用后，会经历两个步骤： 

1. 内核等待 I/O 设备准备好数据 
2. 内核将数据从内核空间拷贝到用户空间。

### Java 中 3 种常见 IO 模型

#### BIO (Blocking I/O)

BIO 属于同步阻塞 IO 模型

同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到在内核把数据拷贝到用户空间。

![image-20230905102522350](http://image.zzq8.cn/img/202309051025531.png)

在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要 一种更高效的 I/O 处理模型来应对更高的并发量。

### NIO (Non-blocking/New I/O)

Java 中的 NIO 于 Java 1.4 中引入，对应 java.nio 包，提供了 Channel , Selector ， Buffer 等抽象。NIO 中的 N 可以理解为 Nonblocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。

Java 中的 NIO 可以看作是 I/O 多路复用模型。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。 跟着我的思路往下看看，相信你会得到答案！ 我们先来看看 同步非阻塞 IO 模型。

![image-20230905132212180](http://image.zzq8.cn/img/202309051322615.png)

同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内 核把数据拷贝到用户空间。

相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。

但是，这种 IO 模型同样存在问题：应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。 这个时候，I/O 多路复用模型 就上场了。

（XD：感觉像CAS Unsafe自旋）

![image-20230905132406455](http://image.zzq8.cn/img/202309051324373.png)

IO 多路复用模型中，**线程首先发起 select 调用，询问内核数据是否准备就绪**，等内核把数据准备好了，用户线程再发起 read 调用。read 调 用的过程（数据从内核空间->用户空间）还是阻塞的。

目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，是目前几乎在所有的操作系统上都有支持

* select 调用 ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。 

* epoll 调用 ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。

IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。

Java 中的 NIO ，有一个非常重要的**选择器 ( Selector )** 的概念，也可以被称为 **多路复用器**。通过它，只需要一个线程便可以管理多个客户端 连接。当客户端数据到了之后，才会为其服务。

![image-20230905132922223](http://image.zzq8.cn/img/202309051329784.png)

> Java NIO（New I/O）在设计上综合了两种模型的特性：I/O 多路复用和同步非阻塞 I/O。
>
> 1. I/O 多路复用模型：NIO 使用选择器（Selector）来实现 I/O 多路复用。选择器允许一个线程同时监听多个通道的事件，例如读就绪或写就绪。这种机制允许一个线程同时处理多个连接，而不需要为每个连接创建一个线程。这是 I/O 多路复用模型的特点。
> 2. 同步非阻塞 I/O 模型：NIO 提供了非阻塞的 I/O 操作方式，这意味着当一个通道没有数据可读取时，读取操作不会阻塞线程，而会立即返回。类似地，当一个通道不能立即写入数据时，写入操作也不会阻塞线程。这种机制使得线程可以在等待 I/O 操作完成的同时继续执行其他任务，而不会被阻塞。这是同步非阻塞 I/O 模型的特点。
>
> 因此，Java NIO 结合了 I/O 多路复用和同步非阻塞 I/O 模型的特性。通过选择器进行 I/O 多路复用，以及使用非阻塞的方式进行读写操作，Java NIO 提供了高效、可扩展的 I/O 处理方式。

> NIO 中的关键组件是 Selector（选择器），它使用了 I/O 多路复用的机制，可以同时监控多个通道的状态。当一个或多个通道就绪时，Selector 会通知应用程序进行相应的处理。这种机制可以提高系统的并发性能，但它并不是 NIO 的核心特性，而是在 NIO 的基础上实现的。

> 所以IO多路复用设计目的其实不是为了快，而是为了解决线程/进程数量过多对服务器开销造成的压力
> ，但它通过减少线程或进程的数量和上下文切换的开销，间接地提高了系统的性能和吞吐量。

#### AIO (Asynchronous I/O)

AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是**异步** IO 模型。

异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进 行后续的操作。

![image-20230905133105910](http://image.zzq8.cn/img/202309051331897.png)

目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。

最后，来一张图，简单总结一下 Java 中的 BIO、NIO、AIO。

![image-20230905133151070](http://image.zzq8.cn/img/202309051331853.png)



## * 什么是泛型擦除机制？为什么要擦除?

Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。

编译器会在编译期间会动态地将泛型 T 擦除为 Object 或将 T extends xxx 擦除为其限定类型 xxx 。

因此，泛型本质上其实还是编译器的行为，为了保证引入泛型机制但不创建新的类型，减少虚拟机的运行开销，编译器通过擦除将泛型类转化 为一般类。

这里说的可能有点抽象，我举个例子：

```java
List<Integer> list = new ArrayList<>();
list.add(12);
//1.编译期间直接添加会报错
list.add("a");
Class<? extends List> clazz = list.getClass();
Method add = clazz.getDeclaredMethod("add", Object.class);
//2.运行期间通过反射添加，是可以的
add.invoke(list, "kl");
System.out.println(list)
```

再来举一个例子 : 由于泛型擦除的问题，下面的方法重载会报错。

```java
public void print(List<String> list) { }
public void print(List<Integer> list) { }
//原因也很简单，泛型擦除之后， List<String> 与 List<Integer> 在编译以后都变成了 List 。
```

既然编译器要把泛型擦除，那为什么还要用泛型呢？用 Object 代替不行吗？

这个问题其实在变相考察泛型的作用： 

* 使用泛型可在编译期间进行类型检测
* 使用 Object 类型需要手动添加强制类型转换，降低代码可读性，提高出错概率。
* 泛型可以使用自限定类型如 T extends Comparable 。

> 评论补充：
>
> 1、对于泛型类，有：
>
> ```java
> public class Generic<T> {
>     T elem;
>     // ...
> }
> // 擦除后相当于
> public class Generic {
>     Object elem;
>     // ...
> }
> ```
>
> 2、对于泛型方法，有：
>
> ```java
> <T> T method(T a, T b);
> 
> // 擦除后
> Object method(Object a, Object b);
> 
>   
> <T extends Number> T method(T a, T b);
> 
> // 擦除后
> Number method(Number a, Number b);
> ```