{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "Piglet",
  "home_page_url": "https://zzq8.cn/",
  "feed_url": "https://zzq8.cn/feed.json",
  "description": "自我提升笔记，记录并输出一切能让自己提升的知识。",
  "favicon": "https://zzq8.cn/favicon.ico",
  "items": [
    {
      "title": "CDN",
      "url": "https://zzq8.cn/code/408-Network/CDN.html",
      "id": "https://zzq8.cn/code/408-Network/CDN.html",
      "summary": "CDN 感觉怪怪的还是没搞好，先就这么用着吧。好像网站貌似变快了？！ 测速网站 还是得看官方文档，搞了一天端午加一周的晚上时间看别人二手文章描述又描述不清！！混淆我！！！！突然开窍看了眼官网描述，草 原来是这个意思： 回源 HOST 即回源域名，CDN 节点在回源时，能够指定访问的源站 IP 地址下具体的站点域名。当您的源站只有一个和加速域名一致的站点...",
      "content_html": "\n<blockquote>\n<p>感觉怪怪的还是没搞好，先就这么用着吧。好像网站貌似变快了？！</p>\n<p><a href=\"https://www.17ce.com/site\" target=\"_blank\" rel=\"noopener noreferrer\">测速网站</a></p>\n<p>还是得看官方文档，搞了一天端午加一周的晚上时间看别人二手文章描述又描述不清！！混淆我！！！！突然开窍看了眼官网描述，草  原来是这个意思：</p>\n<p>回源 HOST\n即回源域名，CDN 节点在回源时，能够指定访问的源站 IP 地址下具体的站点域名。当您的源站只有一个和加速域名一致的站点，默认为加速域名即可，若源站为 COS 源或第三方对象存储时，回源 HOST 不可修改，控制台默认为回源地址。</p>\n<p>说明：\n什么是 CDN 回源 HOST 配置?\n回源 HOST 是指加速域名在 CDN 节点回源过程指向源访问的站点域名，若您在源站服务器内同时部署了若干个 Web 站点，配置正确的回源 HOST 可以帮助您顺利访问指定的站点域名。</p>\n</blockquote>\n<h2>目前配置</h2>\n<h4>DNS 设置</h4>\n<p>| 类型  | 名称 | 值              |\n|</p>\n",
      "date_published": "2024-06-29T00:00:00.000Z",
      "date_modified": "2025-01-28T09:56:38.160Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "博客文章样例",
      "url": "https://zzq8.cn/posts/2024-03-01-blog_example.html",
      "id": "https://zzq8.cn/posts/2024-03-01-blog_example.html",
      "summary": "博客文章内容，支持 Markdown 和 HTML 语言。 加油！内驱力～",
      "content_html": "<blockquote>\n<p>博客文章内容，支持 Markdown 和 HTML 语言。</p>\n</blockquote>\n<p>加油！内驱力～</p>\n",
      "date_published": "2024-03-01T00:00:00.000Z",
      "date_modified": "2025-01-28T09:56:38.161Z",
      "authors": [],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "WebSocket",
      "url": "https://zzq8.cn/code/408-Network/SSE_WS.html",
      "id": "https://zzq8.cn/code/408-Network/SSE_WS.html",
      "summary": "WebSocket 优势 双向实时通信，特有的ws协议，可跨域 填补HTTP在实时通讯的不足 场景 适用低延迟实时通讯 即时消息传递、音视频通话、在线会议和实时数据传输等，可以实现即时的数据传输和交流，不需要用户主动请求或刷新来获取更新数据 协同编辑，想象语雀文档/腾讯文档 使用 如果这时候是想建立 websocket 连接，就会在 HTTP 请求里带...",
      "content_html": "\n<h3>优势</h3>\n<p><strong>双向实时通信</strong>，特有的ws协议，可跨域\n填补HTTP在实时通讯的不足</p>\n<h3>场景</h3>\n<p>适用低延迟实时通讯</p>\n<p>即时消息传递、音视频通话、在线会议和实时数据传输等，可以实现即时的数据传输和交流，不需要用户主动请求或刷新来获取更新数据\n协同编辑，想象语雀文档/腾讯文档</p>\n<h3>使用</h3>\n<p>如果这时候是<strong>想建立 websocket 连接</strong>，就会在 HTTP 请求里带上一些<strong>特殊的 header 头</strong>     告诉服务器，我想从HTTP升级成WS</p>\n<div class=\"language-json line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"json\" data-title=\"json\" style=\"--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34\"><pre class=\"shiki shiki-themes github-light one-dark-pro vp-code\"><code><span class=\"line\"><span style=\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\">Connection: Upgrade</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\">Upgrade: websocket</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\">Sec-WebSocket-Key: T</span><span style=\"--shiki-light:#005CC5;--shiki-dark:#D19A66\">2</span><span style=\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\">a</span><span style=\"--shiki-light:#005CC5;--shiki-dark:#D19A66\">6</span><span style=\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\">wZlAwhgQNqruZ</span><span style=\"--shiki-light:#005CC5;--shiki-dark:#D19A66\">2</span><span style=\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\">YUyg==\\r\\n</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>\n<p>header 头的意思是，浏览器想<strong>升级协议（Connection: Upgrade）</strong>，并且<strong>想升级成 websocket 协议（Upgrade: websocket）</strong>。</p>\n</li>\n<li>\n<p>同时带上一段<strong>随机生成的 base64 码（Sec-WebSocket-Key）</strong>，发给服务器。\n如果服务器正好支持升级成 websocket 协议。就会走 websocket 握手流程，同时根据客户端生成的 base64 码，用某个<strong>公开的</strong>算法变成另一段字符串，放在 HTTP 响应的 <code>Sec-WebSocket-Accept</code> 头里，同时带上<code>101状态码</code>，发回给浏览器。</p>\n<blockquote>\n<p>http 状态码=200（正常响应）的情况，大家见得多了。101 确实不常见，它其实是指<strong>协议切换</strong>。</p>\n</blockquote>\n</li>\n<li></li>\n</ul>\n<p>![image-20240706104311784](/Users/xd/Library/Application Support/typora-user-images/image-20240706104311784.png)</p>\n<h3>心跳机制</h3>\n<p>为了保持 WebSocket 稳定的长连接，在连接建立之后，服务器和客户端之间通过心跳包来保持连接状态，以防止连接因为长时间没有数据传输而被切断。</p>\n<p>一种特殊的数据包不包含任何实际数据，仅用来维持连接状态一个空数据帧</p>\n<p>定期发送，确保链接仍然有效，避免长时间没有数据传输而被中断</p>\n<p>如果一段时间内没有收到对方的心跳包，就可以认为连接已经断开</p>\n<p>扫码原理：HTTP定时轮询（弊端多！）   -》 百度网盘：长轮询</p>\n<p>https://www.bilibili.com/video/BV1Rh4y167Uh?t=122.6 【视频挺好】\nhttps://www.bilibili.com/video/BV19N411474y?t=97.0</p>\n<p>到网站笔记整理</p>\n<p>https://golangguide.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89HTTP%E5%8D%8F%E8%AE%AE%EF%BC%8C%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE.html</p>\n<h3>醍醐灌顶</h3>\n<p><strong>HTTP/1.1 是一种半双工协议，而不是全双工协议。</strong>(设计之初只考虑看看网页，没考虑网页游戏 )</p>\n<p><strong>相比之下，HTTP/2 是全双工协议。HTTP/2 允许同时在同一连接上双向传输多个消息（即多路复用），从而显著提高了传输效率和速度。这使得 HTTP/2 可以更有效地利用网络资源，减少延迟</strong></p>\n<h1>SSE</h1>\n<blockquote>\n<p>ALMP 大语言模型平台用到 - 用户给Bot发消息</p>\n</blockquote>\n<p>Web服务端推送技术</p>\n<p>单向通信，http GET实际还是它，不可跨域</p>\n",
      "image": "https://zzq8.cn/Users/xd/Library/Application Support/typora-user-images/image-20240706104311784.png",
      "date_published": "2024-07-07T14:54:20.000Z",
      "date_modified": "2025-01-28T09:56:38.162Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Software",
      "url": "https://zzq8.cn/code/408-PC/Software.html",
      "id": "https://zzq8.cn/code/408-PC/Software.html",
      "summary": "Software Sublime ctrl+shift+f where处可以指定多个目录 / 排除指定目录下某个文件【高频使用】 shortcut： 1）快速定位到修改过的地方的快捷键-好用 2）书签快捷键 3）还有github中python的批量保存关闭快捷键 image-20240130182956675image-2024013018295667...",
      "content_html": "\n<h2>Sublime</h2>\n<ul>\n<li>\n<h4><a class=\"header-anchor\" href=\"#ctrl-shift-f-where处可以指定多个目录-排除指定目录下某个文件【高频使用】\"><span></span></a><a href=\"https://www.cnblogs.com/daysme/p/6890979.html\" target=\"_blank\" rel=\"noopener noreferrer\">ctrl+shift+f where处可以指定多个目录 / 排除指定目录下某个文件</a>【高频使用】</h4>\n</li>\n<li>\n<h4>shortcut： 1）快速定位到修改过的地方的快捷键-好用     2）书签快捷键    3）还有github中python的批量保存关闭快捷键</h4>\n<ul>\n<li><img src=\"http://images.zzq8.cn/img/image-20240130182956675.png\" alt=\"image-20240130182956675\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20240130182956675</figcaption></li>\n</ul>\n</li>\n<li>\n<h4>在 Sublime Text 4 中，当你尝试替换文本时，它默认会保持替换的文本与原始文本的大小写一致。这意味着，如果你选择替换为大写文本，但原始文本是小写的，替换后的文本也会保持小写。</h4>\n<ul>\n<li>踩坑，ctrl h左下角有个选项 preserve case</li>\n</ul>\n</li>\n<li>\n<h4>搜索可以用正则，正则中的表达式可以用()包到里面，替换的时候可以用 $1..n（代表第1..n个括号） 来复用匹配到的内容！！！真的好用</h4>\n<ul>\n<li><mark>正则组引用</mark></li>\n</ul>\n</li>\n<li>\n<h4><a class=\"header-anchor\" href=\"#快速插入多行递增数字\"><span></span></a><a href=\"https://blog.csdn.net/cxrsdn/article/details/82496800\" target=\"_blank\" rel=\"noopener noreferrer\">快速插入多行递增数字</a></h4>\n<ul>\n<li>\n<h5>ctrl+shift+p</h5>\n</li>\n</ul>\n</li>\n</ul>\n",
      "image": "http://images.zzq8.cn/img/image-20240130182956675.png",
      "date_published": "2024-06-29T10:27:54.000Z",
      "date_modified": "2025-01-28T09:56:38.162Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Seata&XTS",
      "url": "https://zzq8.cn/code/DistributedLock/Seata_XTS.html",
      "id": "https://zzq8.cn/code/DistributedLock/Seata_XTS.html",
      "summary": "Seata&XTS vs 对比与选择 性能： Seata的AT模式性能较高，因为其对数据源的拦截和日志生成进行了优化。 XTS在2PC模式下性能稍低，但在复杂事务一致性需求下更加可靠。 易用性： Seata与Spring等生态系统集成度高，使用起来较为简单。 XTS提供简洁的API，但需要开发者更深入理解TCC模型。 场景适配： Seata适用于需要高...",
      "content_html": "\n<h2>vs</h2>\n<h3>对比与选择</h3>\n<ol>\n<li><strong>性能</strong>：\n<ul>\n<li>Seata的AT模式性能较高，因为其对数据源的拦截和日志生成进行了优化。</li>\n<li>XTS在2PC模式下性能稍低，但在复杂事务一致性需求下更加可靠。</li>\n</ul>\n</li>\n<li><strong>易用性</strong>：\n<ul>\n<li>Seata与Spring等生态系统集成度高，使用起来较为简单。</li>\n<li>XTS提供简洁的API，但需要开发者更深入理解TCC模型。</li>\n</ul>\n</li>\n<li><strong>场景适配</strong>：\n<ul>\n<li>Seata适用于需要高性能且事务模型灵活的场景。</li>\n<li>XTS适用于对事务一致性要求较高的场景，如金融系统。</li>\n</ul>\n</li>\n</ol>\n<h3>选择建议</h3>\n<ul>\n<li>如果你需要一个高性能且易用的分布式事务框架，可以考虑使用Seata。</li>\n<li>如果你对事务一致性有严格要求，且能接受更复杂的实现，可以选择XTS。</li>\n</ul>\n<h1><a class=\"header-anchor\" href=\"#seata\"><span></span></a><a href=\"https://seata.io/zh-cn/docs/overview/what-is-seata.html\" target=\"_blank\" rel=\"noopener noreferrer\">Seata</a></h1>\n<blockquote>\n<p><a href=\"../gulimall/%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E7%BA%A7#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1\">复习Gulimall的本地事务对照着笔记来学习！</a></p>\n<p>看标题的官网链接！！！中文的通俗易懂  下面自己码的也可以看看抄过来的图带点自己好理解的逻辑去理解  <code>@GlobalTransactional</code></p>\n<p><a href=\"../gulimall/03%E3%80%81%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1&amp;%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.pdf#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88\">2PC（Seata是这个的一个变形）</a> 这里具体看 PDF！注意方案是方案框架是框架（落地实现这个方案）</p>\n</blockquote>\n<h2>概念</h2>\n<p>分布式架构肯定是多数据库、多数据源！（买家库，卖家库）甚至在不同的机房。单个就搞笑了</p>\n<p>单体应用被拆分成微服务应用，原来的三个模块被拆分成三个独立的应用,分别使用三个独立的数据源，业务操作需要调用三三 个服务来完成。此时<strong>每个服务内部的数据一致性由本地事务来保证， 但是全局的数据一致性问题没法保证</strong>。</p>\n<figure><img src=\"https://images.zzq8.cn/img/202207081440609.png\" alt=\"img\" tabindex=\"0\" loading=\"lazy\"><figcaption>img</figcaption></figure>\n<p>一句话：<strong>一次业务操作需要跨多个数据源或需要跨多个系统进行远程调用，就会产生分布式事务问题</strong>。</p>\n<p>**一带三：**分布式事务处理过程的一ID+三组件模型</p>\n<ul>\n<li>Transaction ID XID 全局唯一的事务ID</li>\n<li>三组件概念\n<ul>\n<li>TC (Transaction Coordinator) - 事务协调者：维护 全局和分支事务的状态，驱动全局事务提交或回滚。</li>\n<li>TM (Transaction Manager) - 事务管理器：定义全局事务的范围：开始全局事务、提交或回滚全局事务。</li>\n<li>RM (Resource Manager) - 资源管理器：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li>\n</ul>\n</li>\n</ul>\n<p>处理过程：</p>\n<ol>\n<li>TM向TC申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的XID；</li>\n<li>XID在微服务调用链路的上下文中传播；</li>\n<li>RM向TC注册分支事务，将其纳入XID对应全局事务的管辖；</li>\n<li>TM向TC发起针对XID的全局提交或回滚决议；</li>\n<li>TC调度XID下管辖的全部分支事务完成提交或回滚请求。</li>\n</ol>\n<figure><img src=\"https://images.zzq8.cn/img/202207081513288.png\" alt=\"img\" tabindex=\"0\" loading=\"lazy\"><figcaption>img</figcaption></figure>\n<p><mark><code>My Understand：</code>看图说话</mark>   我这里好理解</p>\n<blockquote>\n<p>Seata 分 TC、TM 和 RM 三个角色，TC（Server 端）为单独服务端部署，TM 和 RM（Client 端）由业务系统集成。</p>\n</blockquote>\n<p>TC 协调TM全局事务中的各个分支事务，这个全局调控的人就是Seata服务器（官网下下来运行）</p>\n<p>TM 全局事务看成订单模块 其它小事务RM看成feign调用的</p>\n<blockquote>\n<p>Q：AT 模式（自动）  假如 Account 失败了，但是Stock &amp; Order成功了 那么怎么回滚？？？</p>\n<p>A：UNDO_LOG Table（回滚日志表）  假如提交的是 +2 那就 -2 给补回来回复以前的状态。因为前面事务提交了没办法回滚了（魔改数据库）</p>\n</blockquote>\n<figure><img src=\"https://user-images.githubusercontent.com/68344696/145942191-7a2d469f-94c8-4cd2-8c7e-46ad75683636.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2><a class=\"header-anchor\" href=\"#快速开始\"><span></span></a><a href=\"https://seata.io/zh-cn/docs/user/quickstart.html\" target=\"_blank\" rel=\"noopener noreferrer\">快速开始</a></h2>\n<blockquote>\n<p>官方文档很清楚了！！！Git也有很多场景示例。Seata支持很多模式..   <strong>AT 模式：两阶段提交<a href=\"../gulimall/%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E7%BA%A7\">协议</a>的演变</strong></p>\n</blockquote>\n<p><strong>本地@Transactional     Spring的注解</strong></p>\n<p><strong>全局@GlobalTransactional    SpringCloud的注解（控制分布式事务）：代表这个订单服务是一个全局事务，分支事务用@Transactional就行了</strong></p>\n<p>ps：做项目订单这个全局事务需要把这两个注解都写</p>\n<blockquote>\n<p><a href=\"../gulimall/03%E3%80%81%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1&amp;%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.pdf\">这里具体看 PDF！</a>注意方案是方案框架是框架（落地实现这个方案）  <strong>✔是高并发优先考虑的，用MQ</strong>    订单用异步确保型/商品保存可2PC</p>\n</blockquote>\n<ul>\n<li>\n<p>2PC（Seata是这个的一个变形）还有3PC\n注意和MySQL写日志的两阶段提交区分，是不一样的东西。Seata AT是第一阶段提交+2第二阶段看要不要补偿-2  只适合一般的分布式事务不合适高并发</p>\n</li>\n<li>\n<p>柔性事务-TCC 事务补偿型方案：相当于3PC的手动版\n商城项目用的很多，也有很多框架给你去用。把正常的业务代码按照框架要求拆成z和三部分就行  Try+2/add  Cancel-2/delete</p>\n</li>\n<li>\n<p>柔性事务-最大努力通知型方案（弹幕有公司是这个）✔\n支付宝告诉你有没有支付成功，MQ 一会发个消息告诉你成了 一会发个消息告诉你成了</p>\n</li>\n<li>\n<p>柔性事务-<strong>可靠消息</strong>+最终一致性方案（异步确保型，视频是这个）✔\n也是借助 MQ  总结一句：异步下单，提高并发，提升响应，提升购物体验。</p>\n</li>\n</ul>\n<h2>举例 AT 模式（自动）</h2>\n<blockquote>\n<p>只适用一般的分布式事务控制（例如保存商品会有几次feign优惠券之类的这里不要求高并发），<strong>不适合高并发。下单其实不适合（用MQ）</strong></p>\n</blockquote>\n<ol>\n<li>\n<p>需要数据库加一个回滚表（哪个微服务需要回滚的就得加上）</p>\n</li>\n<li>\n<p><a href=\"https://github.com/seata/seata/releases\" target=\"_blank\" rel=\"noopener noreferrer\">解压并启动seata-server</a>（TC 事务协调器）</p>\n<ol>\n<li>\n<p>导入依赖spring-cloud-starter-alibaba-seata 会自动带上 seata-all-0.7.1</p>\n</li>\n<li>\n<p>注意下载的Seata服务器版本要和 seata-all-0.7.1 对应！！</p>\n<ul>\n<li>registry.conf：服务注册/注册中心配置/事务日志存储位置（global_table&amp;branch_table&amp;lock_table）\n修改 registrytype=nacos 或使用本地文件 file.conf 配置</li>\n</ul>\n</li>\n<li>\n<p>所有想要用到分布式事务的微服务使用seataDataSourceProxy代理自己的数据源</p>\n<ul>\n<li>1.4.1版不用配置数据源，在yaml中开启自动代理数据源，默认是开启的</li>\n</ul>\n</li>\n<li>\n<p><strong>每个微服务,都必须导入 registry.conf file.conf 配置服务名</strong></p>\n<ul>\n<li>\n<p>问题一：<a href=\"https://www.cnblogs.com/LinQingYang/p/13723779.html\" target=\"_blank\" rel=\"noopener noreferrer\">no available server to connect解决</a>（Application要配置seata： spring.cloud.alibaba.seata.tx-service-group: <strong>my_test_tx_group</strong>）</p>\n</li>\n<li>\n<p><a href=\"https://juejin.cn/post/7163549166746992676\" target=\"_blank\" rel=\"noopener noreferrer\">问题二：同一无法连接</a></p>\n</li>\n<li>\n<p>1.4.2直接注册到nacos上 现在的没这么麻烦了吧 可能只需要一个registry.conf了</p>\n</li>\n</ul>\n</li>\n<li>\n<p>给分布式大事务的入口标注@GLobalTransactional   每一个远程的小事务用@Transactional</p>\n</li>\n</ol>\n</li>\n</ol>\n<p>​\tP290避个坑，staea0.7不支持批量保存，我是遍历插入的，体验要stata的效果就好了，不使用高版本的stata也可以</p>\n<p><mark>特别注意：Seata 为用户提供了 AT、TCC、SAGA 和 XA 事务模式</mark></p>\n<blockquote>\n<h4><a class=\"header-anchor\" href=\"#后面看javaguide《面试指北》补充\"><span>后面看JavaGuide《</span></a><a href=\"https://www.yuque.com/snailclimb/mf2z3k/ng9vmg\" target=\"_blank\" rel=\"noopener noreferrer\">面试指北</a>》补充：</h4>\n<p>简单总结一下 2PC 两阶段中比较重要的一些点：</p>\n<ol>\n<li>准备阶段 的主要目的是测试 RM 能否执行 本地数据库事务 操作（!!!注意：这一步并不会提交事务）。</li>\n<li>提交阶段 中 TM 会根据 准备阶段 中 RM 的消息来决定是执行事务提交还是回滚操作。</li>\n<li>提交阶段 之后一定会结束当前的分布式事务</li>\n</ol>\n<p>2PC 的优点：</p>\n<ul>\n<li>实现起来非常简单，各大主流数据库比如 MySQL、Oracle 都有自己实现。</li>\n<li>针对的是数据强一致性。不过，仍然可能存在数据不一致的情况。</li>\n</ul>\n<p>2PC 存在的问题：</p>\n<ul>\n<li>同步阻塞 ：事务参与者会在正式提交事务之前会一直占用相关的资源。比如用户小明转账给小红，那其他事务也要操作用户小明或小红的话，就会阻塞。(XD：所以谷粒商城<strong>高并发</strong>的接口没用Seata，用的是MQ柔性事务)</li>\n<li>数据不一致 ：由于网络问题或者TM宕机都有可能会造成数据不一致的情况。比如在第2阶段（提交阶段），部分网络出现问题导致部分参与者收不到 Commit/Rollback 消息的话，就会导致数据不一致。</li>\n<li>单点问题 ：TM在其中也是一个很重要的角色，如果TM在准备(Prepare)阶段完成之后挂掉的话，事务参与者就会一直卡在提交(Commit)阶段。</li>\n</ul>\n</blockquote>\n<h1>XTS</h1>\n<blockquote>\n<blockquote>\n<ul>\n<li>XTS（eXtended Transaction Service）是一个基于2PC的分布式事务框架，用来保障在大规模分布式环境下数据的一致性</li>\n</ul>\n</blockquote>\n<ul>\n<li>在支付宝广泛使用，涉及到账务、资金的操作，都要使用XTS来确保事务最终一致性</li>\n</ul>\n<p>2010 TCC分库分表（用的最多接触最多）\n2020 XA模式</p>\n<p><a href=\"https://study.antgroup-inc.cn/learn/course/293000055/content/367000437/367000438?tenant=metastudy\" target=\"_blank\" rel=\"noopener noreferrer\">很棒的Movie</a>，视频 PPT 巨好。下面的标注很详细我懂了！\n～～～</p>\n<p>联想 seata\n<a href=\"https://aliyuque.antfin.com/middleware/xts\" target=\"_blank\" rel=\"noopener noreferrer\">https://aliyuque.antfin.com/middleware/xts</a>\nTODO\n永毅：现在打算去 XTS 了，XTS 太慢了\n其他组会议也提到：他们好像都没用分布式锁，性能差？用的事物模板\n<img src=\"http://images.zzq8.cn/img/09175e8024e7028c76cd05eff7628be7.png\" alt=\"image.png\" loading=\"lazy\"></p>\n</blockquote>\n<p><strong>分布式事务：解决数据一致性问题（例如转账A扣钱，B加钱）</strong></p>\n<h2>CAP</h2>\n<p>单机事务：ACID\n分布式事务：CAP（多了网络原因，ACID不适用）\nCP / AP 不能同时存在原因：</p>\n<blockquote>\n<p><strong>分布式系统一定是存在网络传输的</strong>\n就会出现网络延迟/不可达的问题，所以 P 分区容错性一定要满足</p>\n</blockquote>\n<p>分区隔离多个数据副本还没同步完，即节点间数据不一致！\n此时只能在 CP / AP 权衡：\n强一致：等网络恢复同步完，<strong>对外不可用</strong>（zookeeper）\n可用性：读到的数据不一致，可能是还没同步好的节点数据（注册中心）</p>\n<h2>BASE</h2>\n<p>我们大多数的业务系统是对用户提供服务的，一般衡量标准是几个9，对可用性要求是很高的，所以分布式事务对CAP理论中的AP做了延伸，就是BASE理论，它是一种柔性事务理念，它要求分布式系统是基本可用的，允许存在中间态数据，但是一定时间后可以达到最终一致性。这里的基本可用可以理解为响应时间上的增加和非必要功能的降级，中间态数据可以理解是引入了提交过程中的中间状态或者同步过程的延迟。</p>\n<p>ps：几个9的意思问了GPT\n在计算机系统特别是分布式系统领域，当提到系统的可用性时，\"几个9\" 是衡量系统可用性的一种常用方式，即所谓的 \"nine's\" 模型。这种表示法指的是系统在一段时间内保持可用状态的百分比。具体来说：</p>\n<ul>\n<li><strong>1个9（90%）</strong>：系统在 100%的时间里，保证 90%的时间是可用的。</li>\n<li><strong>2个9（99%）</strong>：系统在 100%的时间里，保证 99%的时间是可用的。</li>\n</ul>\n<p>以此类推。\n具体来说，\"几个9\" 反映了系统的可靠性和可用性级别。例如：</p>\n<ul>\n<li><strong>99.9% 可用性</strong>（3个9）：意味着每年只有大约 8.76 小时的不可用时间，这是较高的可用性要求。</li>\n<li><strong>99.999% 可用性</strong>（5个9）：意味着每年只有大约 5.26 分钟的不可用时间，这是非常高的可用性要求，通常应用于对可靠性要求极高的系统，如金融交易系统、航空控制系统等。</li>\n</ul>\n<h2>目标 - 一致性</h2>\n<h3>1PC：无法完成</h3>\n<blockquote>\n<p>目标就是所有节点的提交状态达到一致，要么全部提交、要么全部回滚，\n但是当节点1和节点2都提交完成时，节点3出现异常没有提交，因为只有一个阶段，这样整体就不一致了，因为节点可能在任意时刻出现异常，所以 1PC 是没办法的。</p>\n</blockquote>\n<figure><img src=\"http://images.zzq8.cn/img/57c20af0e574e766247d7f4e2b70e27a.png\" alt=\"image.png\" tabindex=\"0\" loading=\"lazy\"><figcaption>image.png</figcaption></figure>\n<h3>2PC：即二阶段有个反悔的机会</h3>\n<blockquote>\n<p>所以我们必须把提交过程拆成两个部分，也就是两阶段提交，在一阶段完成后可以有一个“反悔”的机会 - 既可以继续提交、也可以撤消\n前面说我们的目标就是让所有节点的提交状态达到一致，要么全部提交、要么全部回滚。其实这个目标就等价于：\n从所有节点中选定一个作为协调者，然后其他节点的状态和它保持一致，就可以了。\n因为事务总会有一个发起者嘛，自然这个发起者就可以作为协调者，其他节点就被称为参与者。\n通过这种方式，除了发起者以外的参与者节点就可以将选择的权力交给发起者来协调，这样发起者就决定了所有节点的状态，就一定是一致的。\n注意这里有一个前提，就是一阶段完成后的中间状态一定可以向前提交，也可以回滚，如果不能满足，那就应该在一阶段就直接失败。\n这就是两阶段提交，常见的分布式事务方法基本都是基于两阶段衍生出来的。</p>\n</blockquote>\n<figure><img src=\"http://images.zzq8.cn/img/f6c17e91b32b47b9752a94f17ca4260c.png\" alt=\"image.png\" tabindex=\"0\" loading=\"lazy\"><figcaption>image.png</figcaption></figure>\n<h2>XTS发展-四种模式</h2>\n<blockquote>\n<p>接下来我们主要介绍的是<strong>TCC模式</strong>，蚂蚁大部分应用使用的都是TCC模式，大家以后接触最多的就是TCC，FMT，saga和XA模式会放到后边的扩展部分进行介绍。</p>\n</blockquote>\n<p><img src=\"http://images.zzq8.cn/img/eba3e9147240d1fe83ee3fc78f1f6e54.png\" alt=\"image.png\" loading=\"lazy\">\nTCC模式：二阶段提交模式，一阶段try内执行本地事务和远程调用，根据远程调用的成功和失败来决定后续调用 confirm 还是 cancel。\nXA模式：需要数据库支持，实现2PC协议，这个时候数据库便能支持分布式事务了。</p>\n<p>思考1：TCC模式需要设计者考虑中间状态，try的过程中并不直接对数据进行变更，而是通过中间值体现，在一阶段处理结束的时候，通过commit 或 cancel 来将中间值转化为最终值。需要有良好的设计思维来设计模型。\n思考4：XA模式性能注定不会很好，分布式事务基本都具有RPC调用的特性，此时数据库便会存在长事务的情况。正常来说，开发规范都不允许事务内存在RPC调用就是防止长事务的存在。</p>\n<p>总结：TCC业务侵入性大但是性能更优，FMT和XA模式无法满足高并发场景，但是这两者都无需开发者关注，配置即可用。SAGA模式个人不太喜欢，这种补偿机制问题颇多，事务补偿异常怎么处理？事务隔离性差导致的数据污染如何处理？这些都是开发者需要关注的东西。</p>\n<h1>TCC模式</h1>\n<h2>概念</h2>\n<blockquote>\n<p>先介绍一下TCC几个概念，其实TCC名字就是根据两阶段来起的，第一阶段执行try服务，所有检查操作，可能会导致事务提交失败的操作全都应该放到try中进行。\n第二阶段是commit和cancel操作，提交就是commit，反悔了要回滚就是cancel操作，二阶段只会选其中一个执行。\n<strong>发起方，是分布式事务的协调者，负责编排参与者，推进执行二阶段。将执行过程记录事务日志。</strong></p>\n</blockquote>\n<p><strong>帮助理解的 PointKey World：</strong>\n<strong>主事务 &amp; 分支事务</strong>\n<strong>TM：发起者</strong>\n<strong>RM：参与者</strong>\n<img src=\"http://images.zzq8.cn/img/fb36ae860874979dc1ac1eea159a650e.png\" alt=\"image.png\" loading=\"lazy\"></p>\n<h2>经典使用场景</h2>\n<blockquote>\n<p>首先看一个典型的使用场景，app1,app2,app3组成一个分布式系统，\napp1分别调用app2和app3做了insert和delete操作，同时app1本身\n做了一个update操作，这样整个分布式事务包含3个系统，3个操作。</p>\n</blockquote>\n<p><img src=\"http://images.zzq8.cn/img/731b95aa4b87a3a410b67eaac6ba5ffd.png\" alt=\"image.png\" loading=\"lazy\">\n<strong>那如何将这个事务设计成TCC二阶段呢？</strong>\n比如针对insert这类增加的操作，一阶段就不能直接增加，而是应该在做完检查后，添加一个未达数据，二阶段将未达数据进行追加或者删除。对Delete这类减少操作，一阶段也是不能直接减少，而是应该先做业务检查，然后冻结住，在二阶段将冻结的数据彻底删除或者回滚解除冻结。</p>\n<h2>实现原理：TCC两阶段提交</h2>\n<blockquote>\n<p>图 !important</p>\n</blockquote>\n<p><img src=\"http://images.zzq8.cn/img/7fa0b3259ae9f81eefacea36e8e1ecf4.png\" alt=\"image.png\" loading=\"lazy\">\nApp1是整个事务的发起者，为了能够代表整个事务的状态，发起者必须要有一个本地事务，<strong>并且对所有参与者一阶段的调用，都需要在这个本地事务内发生</strong>，如果在一阶段有任意节点报错了，无法完成，发起者本地事务就需要回滚，如果所有节点一阶段都可以顺利完成，本地事务才能提交。\n本地事务结束后表示一阶段已经完成，可以进入二阶段，由于本地事务ACID的原子性，本地事务是一定处于<strong>终态的</strong>，要么是提交状态，要么是回滚状态，就算超时也是回滚状态。\n所以二阶段就可以根据本地事务的状态，来协调各个参与者二阶段，是提交还是回滚，二阶段的提交和回滚是不确定的，<strong>所以二阶段是由框架自动执行的</strong>\n这个整个过程中会通过记录日志表的方式，持久化所有发生的动作，日志表都是记录到发起者的业务数据库中的，叫做同库模式，事务启动时，会生成一条主事务记录business_activity，表示这一次分布式事务，每调用一次参与者，会生成一条分支事务记录business_action，它和主事务记录是一对多的关系。\n那一致性是怎么保证的呢？</p>\n<h2>⭐事务一致性保证（重点）</h2>\n<p><img src=\"http://images.zzq8.cn/img/8cfa32e52651e1a88351c1b024621975.png\" alt=\"image.png\" loading=\"lazy\">\n这一页是对上一页的一个细化，也是说明<strong>xts如何实现一致性</strong>的核心重点。\n发起者在启动事务的时候，先要启动一个本地事务，然后在这个本地事务中调用一下xts提供的start方法，这样xts会立即在<strong>独立的事务模板</strong>中插入一条主事务记录，状态为初始状态，紧接着xts在发起者本地事务中，对刚插入的主事务记录，执行一次状态更新操作，由初始状态更新为确定提交状态，\n前面说过，发起者本地事务可以决定整体分布式事务的状态，注意这里的更新操作，通过这一步就可以将主事务日志记录和业务本地事务绑定到一起，所以主事务记录的状态就可以反应整个分布式事务的状态了。\n<strong>那怎么绑在一起的？因为xts是在发起者本地事务中执行的更新，本地事务提交，主事务记录肯定就是确定提交状态了，如果本地事务回滚，刚才的更新操作也会跟着回滚到初始状态。</strong>\n到这里xts的start方法内部就执行完成了，然后发起者本地事务中的业务代码开始调用各个参与者的一阶段，xts会拦截到每一次调用，还是在独立事务模板中插入一条分支事务记录，然后再执行调用，这样就可以把具体调用过哪些参与者持久化记录下来。\n<strong>那主事务记录和分支事务记录的插入操作为什么需要独立事务模板</strong>？是为了本地事务回滚时不影响事务日志的持久化，如果在本地事务中插入事务日志，假如调用某个参与者失败了，本地事务回滚后，插入的事务记录也会一起回滚消失，就不知道整个事务的状态了，另外具体调用过哪些参与者也不知道了，这要是为什么要再加<strong>两张表记录</strong>的原因，不受本地事务的影响。\n一阶段完成后，xts会自动执行二阶段，根据本地事务的状态决定调用参与者的commit方法还是cancel方法，二阶段完成后，直接删除事务日志。</p>\n<p>疑问：\n两条事务线：\n绿色线使用单独的事务模板，事务传播特性为PROPAGATION_REQUIRES_NEW\n红色线使用发起方本地事务模板，事务传播特性为PROPAGATION_REQUIRES\n请问绿线先走红线后走，红线会不会加到绿线的事务</p>\n<p>解答：\n总结起来，红线事务会作为单独的事务存在，与绿线事务独立，互不影响。\n当红线在绿线事务内部开始时，红线事务使用 PROPAGATION_REQUIRED规则，它会检索到当前存在的事务（即绿线的事务）。但是由于绿线的事务是独立的事务，不会发生嵌套，因此红线的事务实际上会是独立的事务（红线本地事务）。</p>\n<h2>事务日志状态</h2>\n<p><img src=\"http://images.zzq8.cn/img/f40bb7c561b498c208ebb6f3e273111d.png\" alt=\"image.png\" loading=\"lazy\">\n再看一下在执行过程中，主事务日志状态的转化，在business_activity表中通过state列表示状态。\n主事务记录是在独立事务中插入的，状态为初始化状态I，可以保证不管本地事务提交不提交，主事务记录一定存在，然后在发起者本地事务中更新为确定提交状态C。\n接下来如果本地事务提交，更新操作也会提交，主事务记录状态就是确定提交C，\n如果本地事务回滚，更新操作也会回滚，主事务记录状态就会回滚到初始化状态l。\n这样有了主事务日志，如果执行过程中出现异常，就可以直接通过主事务日志的状态来表示整个分布式事务的状态了，实际上，事务日志就是为了出现异常时恢复用的，不做业务使用，<strong>如果二阶段正常可以完成，事务日志就用不到，可以直接删除</strong>，客户端执行过程中使用的日志信息都是放到内存中的，不查db，性能高。\n那什么情况下会用到呢？</p>\n<h2>XTS事务兜底恢复</h2>\n<p><img src=\"http://images.zzq8.cn/img/387d323bff005e77a1b43838d95a11f0.png\" alt=\"image.png\" loading=\"lazy\">\n接下来就是XTS事务兜底恢复，如果二阶段在执行参与者B的提交方法时机器断电了，虽然整体事务没有完成，但是发起者数据库中会有这条事务的主事务记录和两个分支事务记录。\n<strong>Xts的恢复系统dtap就会到发起者的数据库中，定时捞取到这条主事务记录，发现状态为确定提交状态C，就可以判定这条事务是要提交的，再查询一下关联的business_action分支事务记录，查到这两个参与者信息后，顺序的调用参与者的confirm方法就可以完成恢复。同样的，如果主事务日志是初始化状态l，就调用参与者的cancel方法。</strong>\n然后在二阶段完成后，直接删除发起者数据库中的这笔事务日志记录，就可以完成事务的恢复。\n这里为了能让dtap可以查询发起者数据源和调用参与者服务，dtap提供了控制台来录入这两个信息，需要人工去录入。</p>\n<p>思考：这里的第4步会出现什么问题呢？可能会调用两次，应用调用了一次后才断电（/ 超时），dtap恢复时，不知道是否调用过，只能再次调用，需要支持<strong>幂等</strong>\n思考：如果dtap调用参与者B的二阶段confirm时也失败，如何操作？</p>\n<ul>\n<li>分布式事务的状态是由本地事务决定的！本地事务状态一定是一个终态</li>\n<li>其他原因再ci</li>\n</ul>\n<h2>TCC使用规范</h2>\n<ul>\n<li>XTS分布式事务TCC是基于两阶段提交（2 phase commit，简称2pc）原理的。</li>\n<li>分布式事务必须在本地事务模板中进行。</li>\n<li>事务发起者是分布式事务的协调者，发起者本地事务的最终状态（提交或回滚）决定整个分布式事务的最终状态。</li>\n<li>执行过程发起者会生成事务日志到业务库的business_activity，business_action表。</li>\n<li>事务参与者的方法需要支持两阶段。发起方（使用者）只关注第一阶段的方法，第二阶段由框架自动调用。参与者需要保证：第一阶段如果成功了，第二阶段必须保证成功。</li>\n<li>第一阶段完成，第二阶段没执行完的事务需要进行事务恢复，要到dtap去配置发起者和参与者信息，定时（每分钟）捞取发起者db数据business_acitvity进行第二阶段执行。</li>\n</ul>\n<p>一阶段一定能完成\n恢复系统其实是做了应用客户端二阶段没完成的操作。</p>\n<h2>TODO - 理论视频  &amp; 案例</h2>\n<p>然后通过几个TCC典型金融案例实践加深对XTS的理解</p>\n<h1>XA模式</h1>\n<figure><img src=\"http://images.zzq8.cn/img/331a77d65115a134117aff63e2c3ce75.png\" alt=\"image.png\" tabindex=\"0\" loading=\"lazy\"><figcaption>image.png</figcaption></figure>\n",
      "image": "https://images.zzq8.cn/img/202207081440609.png",
      "date_published": "2024-06-29T08:14:25.000Z",
      "date_modified": "2025-01-28T09:56:38.169Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Git",
      "url": "https://zzq8.cn/code/ZOther/Git.html",
      "id": "https://zzq8.cn/code/ZOther/Git.html",
      "summary": "Git 基础学习 ✨Git 学习游戏网站 https://m.runoob.com/git/git-basic-operations.html 有时间再梳理这篇文章, 只保留有用的 不要繁琐,繁琐了不会看 img workspace：工作区 staging area：暂存区/缓存区 local repository：版本库或本地仓库 remote re...",
      "content_html": "\n<h2>基础学习</h2>\n<blockquote>\n<p>✨<a href=\"https://oschina.gitee.io/learn-git-branching/\" target=\"_blank\" rel=\"noopener noreferrer\">Git 学习游戏网站</a></p>\n<p>https://m.runoob.com/git/git-basic-operations.html</p>\n<p>有时间再梳理这篇文章, 只保留有用的   不要繁琐,繁琐了不会看</p>\n</blockquote>\n<img src=\"https://www.runoob.com/wp-content/uploads/2015/02/git-command.jpg\" alt=\"img\" style=\"zoom:150%;\">\n<ul>\n<li>workspace：工作区</li>\n<li>staging area：暂存区/缓存区</li>\n<li>local repository：版本库或本地仓库</li>\n<li>remote repository：远程仓库</li>\n</ul>\n<h2>日常使用</h2>\n<p>日常自己仓库就三步:</p>\n<ul>\n<li>git status -sb (--short, --branch)   <mark>xd 不会了就 git status -help</mark></li>\n<li>git commit -av</li>\n<li>git push</li>\n</ul>\n<p>其他常用:</p>\n<ul>\n<li>\n<p>git log --oneline (单行形式展示日志)</p>\n</li>\n<li>\n<p>使用 git checkout 命令回退指定的文件到上一个版本，<strong>多个文件用空格隔开</strong></p>\n<ul>\n<li>git checkout HEAD~1 -- package-lock.json package.json</li>\n</ul>\n</li>\n<li>\n<p>git rm -r --cached xx (清除指定文件的 git 版本控制)</p>\n</li>\n<li>\n<p>git checkout &lt;上一个版本的提交哈希值&gt; -- &lt;文件路径&gt; （git 回滚指定文件到上一个版本）</p>\n<ul>\n<li>【实测】如果你想要抛弃工作区的修改，可以使用git checkout命令。git checkout -- .</li>\n</ul>\n</li>\n</ul>\n<p>扩展知识：</p>\n<ul>\n<li>\n<p>规定了<a href=\"https://zhuanlan.zhihu.com/p/182553920\" target=\"_blank\" rel=\"noopener noreferrer\">commit message</a>的格式（TODO，我个人觉得还蛮重要，看网站提到的背景）</p>\n</li>\n<li>\n<p><code>--</code>在命令行中的作用是提供一个明确的分隔符，以确保命令的选项、参数或文件路径被正确解析。</p>\n<ul>\n<li>例如，<code>git log -- -file.txt</code>中的<code>--</code>用于明确表示<code>-file.txt</code>是参数而不是选项</li>\n<li>例如，<code>git checkout branch-name -- file.txt</code>中的<code>--</code>用于分隔<code>branch-name</code>和<code>file.txt</code>，以明确表示<code>file.txt</code>是文件路径而不是分支名称。</li>\n</ul>\n</li>\n</ul>\n<h4>IDEA 中 git Merge Select into Current 和 Pull into Current using merge有什么区别</h4>\n<blockquote>\n<ul>\n<li>Merge Select into Current 适用于合并指定远程分支的更改到当前分支。</li>\n<li>Pull into Current using merge 适用于拉取远程分支的最新更改并合并到当前分支。</li>\n</ul>\n</blockquote>\n<ul>\n<li>\n<p>Merge Select into Current: <strong>实测没有fetch，直接以现有的log记录去merge</strong></p>\n<ul>\n<li>git merge refs/remotes/origin/gptsh_dlx_b1</li>\n</ul>\n</li>\n<li>\n<p>Pull into Current using merge: <strong>实测先fetch再merge</strong></p>\n<ul>\n<li>git fetch origin --recurse-submodules=no --progress --prune\n<ul>\n<li>如有信息输出：remote: Total 10 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)\nFrom gitlab.alipay-inc.com:cangxi.lj/gptsh\n5e991b2..d7972bd  gptsh_dlx_b1 -&gt; origin/gptsh_dlx_b1</li>\n<li>如没信息就这一步完了就 return，提示 All filles are up to date</li>\n</ul>\n</li>\n<li>git merge origin/gptsh_dlx_b1 --no-stat -v</li>\n</ul>\n</li>\n</ul>\n<h1>-</h1>\n<h1>-</h1>\n<hr>\n<h1>繁琐的以前</h1>\n<h2><a class=\"header-anchor\" href=\"#_1-前置配置\"><span></span></a><a href=\"https://blog.csdn.net/weixin_42310154/article/details/118340458\" target=\"_blank\" rel=\"noopener noreferrer\">1.前置配置</a></h2>\n<blockquote>\n<p>云服务器的 Git 我捣鼓了好久~\n由于云服务器网络、地区CN   http协议去连 Github 有点抽风，固我第一次尝试了 ssh 协议！！！   好使</p>\n</blockquote>\n<ol>\n<li>生成ssh key  <code>ssh-keygen -t rsa -C \"xxx@xxx.com\"</code></li>\n<li>获取ssh key公钥内容（id_rsa.pub）   <code>cat ~/.ssh/id_rsa.pub</code></li>\n<li>把 cat 到的公钥内容放入 Github SSH配置里</li>\n<li>验证是否设置成功   <code>ssh -T git@github.com</code></li>\n</ol>\n<h3>通俗解释！！</h3>\n<p>重点来了：<strong>一定要知道ssh key的配置是针对每台主机的！</strong>，比如我在某台主机上操作git和我的远程仓库，想要push时不输入账号密码，走ssh协议，就需要配置ssh key，放上去的key是<strong>当前主机的ssh公钥</strong>。那么如果我换了一台其他主机，想要实现无密登录，也就需要重新配置。</p>\n<p>下面解释开头提出的问题：\n（1）为什么要配？\n配了才能实现push代码的时候不需要反复输入自己的github账号密码，更方便\n（2）每使用一台主机都要配？\n是的，每使用一台新主机进行git远程操作，想要实现无密，都需要配置。并不是说每个账号配一次就够了，而是每一台主机都需要配。\n（3）配了为啥就不用密码了？\n因为配置的时候是把当前主机的公钥放到了你的github账号下，相当于当前主机和你的账号做了一个关联，你在这台主机上已经登录了你的账号，此时此刻github认为是该账号主人在操作这台主机，在配置ssh后就信任该主机了。所以下次在使用git的时候即使没有登录github，也能直接从本地push代码到远程了。当然这里不要混淆了，你不能随意push你的代码到任何仓库，你只能push到你自己的仓库或者其他你有权限的仓库！</p>\n<h2>1.备份 MinIO</h2>\n<blockquote>\n<p>场景：备份 MinIO 的文件到 Git</p>\n<ol>\n<li>使用 <code>crontab -e</code></li>\n<li>一分钟执行一次  <code>* * * * * /home/minio/data/blog/test.sh  &gt;&gt; /home/minio/data/test.log 2&gt;&amp;1</code></li>\n</ol>\n<p>问题：我需要保证我的shell脚本的git命令 auth 这一步</p>\n<p>​\t手动一行行命令的时候用 <code>http</code> 可以：<code>git remote set-url origin http://github.com/zzq8/MinIO-upupor.git</code></p>\n<p>​\t但是shell中批量总是报错！！！auth问题，网上冲浪发现用ssh好使   1）需要云服务器加私钥 2）把公钥加到Git\n​\t<code>git remote set-url origin git@github.com:zzq8/MinIO-upupor.git</code></p>\n</blockquote>\n<p>token   可以当密码auth的时候</p>\n<p>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</p>\n<h1>GitHub搜索技巧</h1>\n<blockquote>\n<p>不要小看这个，真的可以挖掘Github这个宝藏库</p>\n</blockquote>\n<ul>\n<li>\n<p>in关键字限制搜索范围 ',' 是或的意思  <code>xxx in:name,readme,description</code></p>\n</li>\n<li>\n<p>查找star大于1000，fork数在500到1000 <code>xxx stars:&gt;1000 forks:500..1000</code></p>\n</li>\n<li>\n<p>awesome系列，一般用来收集学习、工具、书籍类相关的项目 <code>awesome xxx</code></p>\n<ul>\n<li>【陌生】搜出来第一条会有副红色眼镜    言下之意，你要学什么东西就用这个命令试试。   至少我搜了下SpringBoot还是蛮不错的</li>\n</ul>\n</li>\n<li>\n<p>高亮显示某行代码 一行：代码地址后面紧跟 <code>#L10</code> 多行：<code>#Lx - #Ln</code></p>\n</li>\n<li>\n<p>项目内搜索 使用英文字母 <code>t</code> ,开启项目内搜索</p>\n</li>\n</ul>\n<h1>一、常规流程</h1>\n<blockquote>\n<p>命令行还是可以会一下，后面其实都可以用 TortoiseGit 图形化操作了...</p>\n</blockquote>\n<h2>前置设置</h2>\n<div class=\"language-bash line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"bash\" data-title=\"bash\" style=\"--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34\"><pre class=\"shiki shiki-themes github-light one-dark-pro vp-code\"><code><span class=\"line\"></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div></div></div>",
      "image": "https://images.zzq8.cn/img/202206011611310.png",
      "date_published": "2024-04-13T08:39:03.000Z",
      "date_modified": "2025-01-28T09:56:38.174Z",
      "authors": [],
      "tags": [
        "Code"
      ]
    }
  ]
}