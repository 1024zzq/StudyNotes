import{_ as c}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as i,o as p,c as d,e,f as t,b as o,w as s,a as l}from"./app-zf_nMha2.js";const u={},h=e("h1",{id:"httprequest",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#httprequest"},[e("span",null,"HttpRequest")])],-1),m={href:"https://blog.csdn.net/f110300641/article/details/115342356",target:"_blank",rel:"noopener noreferrer"},g=l('<blockquote><p>这里放一些常见的，具体的去搜</p></blockquote><h2 id="一、general-请求行" tabindex="-1"><a class="header-anchor" href="#一、general-请求行"><span>一、General（请求行）</span></a></h2><ul><li><p>Request URL: http://127.0.0.1:8848/nacos/</p></li><li><p>Request Method: GET</p></li><li><p>Status Code:304（响应状态码）</p></li><li><p>Remote Address: 127.0.0.1:8848（HTTP请求的源地址）</p><ul><li><p>HTTP协议在三次握手时使用的就是这个Remote Address地址，在发送响应报文时也是使用这个Remote Address地址。因此，如果请求者伪造Remote Address地址，他将无法收到HTTP的响应报文，此时伪造没有任何意义。这也就使得Remote Address默认具有防篡改的功能。</p></li><li><p>如果http请求经过代理服务器转发，用户的真实ip会丢失，为了避免这个情况，代理服务器通常会增加一个叫做x_forwarded_for的头信息，把连接它的客户端IP（即你的上网机器IP）加到这个头信息里，这样就能保证网站的web服务器能获取到真实IP</p></li></ul></li><li><p>Referrer Policy: strict-origin-when-cross-origin（引用策略，有八种）</p><ul><li>Referer提供访问来源的信息，告诉服务器，用户在访问当前资源之前的位置，发生传场景包含：加载图片、样式文件、JS文件、请求。浏览器会将当前网址作为Referer字段，放在 HTTP 请求的头信息发送。</li></ul></li></ul><h2 id="二、request-headers-请求头" tabindex="-1"><a class="header-anchor" href="#二、request-headers-请求头"><span>二、Request Headers（请求头）</span></a></h2>',4),k=l("<li><p><code>Accept</code>: text/html, application/xhtml+xml, application/xml;q=0.9, <em>/</em>;q=0.8</p><ul><li>请求头用来告知服务器 客户端可以处理的内容类型(用MIME类型来表示)，借助内容协商机制服务器从备选项中选择一项进行应用，并使用Content-Type应答头通知客户端它的选择。</li></ul></li><li><p>Accept-Encoding: gzip, deflate, br</p><ul><li>请求头用来告知服务器 客户端可以处理的编码方式</li></ul></li><li><p>Accept-Language: zh-CN,zh-TW;q=0.9,zh;q=0.8,en;q=0.7</p></li><li><p>Cache-Control: max-age=0</p></li><li><p>Content-Type：xxx 这个补充到笔记，请求也有这不光response</p></li><li><p>Connection: keep-alive</p><ul><li><p>面试常问1.1和1.0的区别。。有必要说明的是，HTTP/1.0 仍提供了长连接选项，即在请求头中加入<code>Connection: Keep-alive</code>。同样的，在 HTTP/1.1 中，如果不希望使用长连接选项，也可以在请求头中加入<code>Connection: close</code>，这样会通知服务器端：“我不需要长连接，连接成功后即可关闭”。</p><hr><p>著作权归Guide所有 原文链接：https://javaguide.cn/cs-basics/network/http1.0-vs-http1.1.html#%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F</p></li></ul></li><li><p><code>Cookie</code>: JSESSIONID=B4717473F69FD975072100C7E181E807; JSESSIONID=BF468917A7A82EB64D8E913D8F4457F5</p><ul><li>这两个Name一样但是Path不一样</li><li><mark>Cookie是Web服务器发送给客户端的一小段信息，客户端请求时，可以读取该信息发送到服务器端</mark></li></ul></li>",7),q={href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/DNT",target:"_blank",rel:"noopener noreferrer"},b=e("strong",null,"D",-1),_=e("strong",null,"N",-1),v=e("strong",null,"T",-1),x=e("ul",null,[e("li",null,"**已弃用：**不再推荐此功能。尽管某些浏览器可能仍然支持它")],-1),f=l("<li><p><code>Host</code>: 127.0.0.1:8848</p><ul><li>场景：Ngixn 转发会丢失这个，需配置的时候加个参数set上去</li></ul></li><li><p>If-Modified-Since: Fri, 29 Apr 2022 02:20:32 GMT</p></li><li><p>Sec-Fetch-Dest: document</p></li><li><p>Sec-Fetch-Mode: navigate</p></li><li><p>Sec-Fetch-Site: same-origin</p></li><li><p>Sec-Fetch-User: ?1</p></li><li><p>Upgrade-Insecure-Requests: 1</p></li><li><p>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36 sec-ch-ua: &quot;Not?A_Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;108&quot;, &quot;Google Chrome&quot;;v=&quot;108&quot;</p></li><li><p>sec-ch-ua-mobile: ?0</p></li><li><p>sec-ch-ua-platform: &quot;Windows&quot;</p></li>",10),C={id:"三、response-headers-响应头",tabindex:"-1"},T={class:"header-anchor",href:"#三、response-headers-响应头"},S={href:"https://www.runoob.com/http/http-header-fields.html",target:"_blank",rel:"noopener noreferrer"},R=l(`<blockquote><p>包含服务器类型，日期，长度，内容类型等</p><p>响应正文响应正文就是服务器返回的HTML页面或者json数据 text/html application/json</p></blockquote><ul><li><p>Connection: keep-alive</p><ul><li>可以看到请求头也有这个属性</li><li>服务器可以解析请求头中的 Connection 字段来了解客户端的连接偏好，并相应地处理连接的保持与关闭。</li></ul></li><li><p>Content-Encoding: gzip</p></li><li><p>Content-Language: zh-CN</p></li><li><p><code>Content-Type</code>: text/html;charset=utf-8</p><ul><li>对应请求头的 Accept 告诉你采用的是哪个</li></ul></li><li><p>Date: Thu, 12 Jan 2023 08:27:16 GMT</p></li><li><p><code>Set-Cookie</code>: xxx</p><ul><li>设置和页面关联的Cookie</li></ul></li><li><p>Content-Length: 6867</p></li><li><p>Keep-Alive: timeout=60</p><ul><li><p>这意味着在客户端与服务器之间的通信中，如果在 60 秒内没有新的请求或响应发生，连接可能会被关闭。</p></li><li><p>CATIC 商网就是做了这个限制，然后直接报错 504 (Gateway Time-out) 但实际上，你只要请求丢过去了他后台服务器就还在执行。返回值如果不重要的话，我这里就是 return true 不太重要 响应值丢了就丢了 反正接口幂等了</p></li><li><p><strong>Response Headers的参数Keep-Alive: timeout=60该在哪里设置</strong></p><ul><li><p><strong>---对于Apache服务器：</strong> 对于 Apache Tomcat，你可以通过修改 <code>server.xml</code> 文件来配置</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
           connectionTimeout=&quot;60&quot; /&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>---对于Nginx服务器：</strong> 在 Nginx 的配置文件（通常是 <code>nginx.conf</code> 或位于 <code>sites-available</code> 目录中的虚拟主机配置文件）中，可以添加以下指令来设置 <code>Keep-Alive</code> 的超时时间：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>keepalive_timeout 60s;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上述配置中，<code>keepalive_timeout</code> 设置为 <code>60s</code> 表示超时时间为60秒。</p><p>请注意，以上配置示例仅供参考，实际配置可能会根据你的服务器环境和需求而有所不同。在修改服务器配置之前，请确保备份现有配置文件，并确保你对服务器配置有足够的了解。</p><p>完成配置更改后，重新启动服务器以使更改生效。之后，服务器会在响应头中包含 <code>Keep-Alive: timeout=60</code>，指示客户端保持持久连接的时间为60秒。</p></li></ul></li></ul></li></ul><hr>`,3),w={id:"四、xhr",tabindex:"-1"},y={class:"header-anchor",href:"#四、xhr"},H={href:"https://zh.wikipedia.org/wiki/XMLHttpRequest",target:"_blank",rel:"noopener noreferrer"},P=l('<blockquote><p>XMLHttpRequest</p><p>https://www.cnblogs.com/xiaohuochai/p/6036475.html</p><p>概括起来，就是一句话，ajax通过原生的<code>XMLHttpRequest</code>对象发出HTTP请求，得到服务器返回的数据后，再进行处理</p><p>Chrome F12 筛选请求的时候可以勾这个(就只会捕获 Ajax 请求)，其实本质是 ajax 核心。。。。我理解为所有交互的请求都是这个 ajax技术的核心是XMLHttpRequest对象(简称XHR)</p></blockquote><hr><p>http协议本身是一种无状态的协议</p><p>会话跟踪是一种灵活、轻便的机制，它使Web上的状态编程变为可能。 HTTP是一种无状态协议，每当用户发出请求时，服务器就会做出响应，客户端与服务器之间的联系是离散的、非连续的。当用户在同一网站的多个页面之间转换时，根本无法确定是否是同一个客户，会话跟踪技术就可以解决这个问题。当一个客户在多个页面间切换时，服务器会保存该用户的信息。 有四种方法可以实现会话跟踪技术：URL重写、隐藏表单域、Cookie、Session。 1）.隐藏表单域：<input type="hidden">，非常适合步需要大量数据存储的会话应用。 2）.URL 重写:URL 可以在后面附加参数，和服务器的请求一起发送，这些参数为名字/值对。 3）.Cookie:一个 Cookie 是一个小的，已命名数据元素。服务器使用 SET-Cookie 头标将它作为 HTTP 响应的一部分传送到客户端，客户端被请求保存 Cookie 值，在对同一服务器的后续请求使用一个 Cookie 头标将之返回到服务器。与其它技术比较，Cookie 的一个优点是在浏览器会话结束后，甚至 在客户端计算机重启后它仍可以保留其值 4）.Session：使用 setAttribute(String str,Object obj)方法将对象捆绑到一个会话</p><h2 id="session-缺点" tabindex="-1"><a class="header-anchor" href="#session-缺点"><span>Session 缺点</span></a></h2><blockquote><p><strong>其实Session是依据Cookie来识别是否是同一个用户</strong>。</p></blockquote><h3 id="为什么要使用session技术" tabindex="-1"><a class="header-anchor" href="#为什么要使用session技术"><span>为什么要使用Session技术？</span></a></h3><p><strong>Session比Cookie使用方便，Session可以解决Cookie解决不了的事情【Session可以存储对象，Cookie只能存储字符串。】。</strong></p><h3 id="sessin-缺点" tabindex="-1"><a class="header-anchor" href="#sessin-缺点"><span>Sessin 缺点：</span></a></h3>',9),A=e("strong",null,"Session",-1),E=e("strong",null,"认证用户的增多，服务端的开销会明显增大",-1),L=e("li",null,[e("strong",null,"CSRF"),t(": 因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到"),e("strong",null,"跨站请求伪造的攻击")],-1),M=e("li",null,[e("strong",null,[e("mark",null,"扩展性")]),t(": 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户"),e("strong",null,"下次请求还必须要请求在这台服务器上"),t(",这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。")],-1),z=e("p",null,[t("解决系统之间Session不共享问题：把Session数据放在Redis中（使用Redis模拟Session）【"),e("strong",null,"建议"),t("】")],-1),N=e("p",null,"针对Cookie存在跨域问题，有几种解决方案：",-1),j=e("ol",null,[e("li",null,"服务端将Cookie写到客户端后，客户端对Cookie进行解析，将Token解析出来，此后请求都把这个Token带上就行了"),e("li",null,"多个域名共享Cookie，在写到客户端的时候设置Cookie的domain。"),e("li",null,"将Token保存在SessionStroage中（不依赖Cookie就没有跨域的问题了）")],-1),U={id:"cookie",tabindex:"-1"},F={class:"header-anchor",href:"#cookie"},G={href:"https://mp.weixin.qq.com/s/JW7mxXEqrV1rZ_pQOteXGQ",target:"_blank",rel:"noopener noreferrer"},B=l(`<h2 id="token" tabindex="-1"><a class="header-anchor" href="#token"><span>token</span></a></h2><blockquote><p>JWT -- JSON WEB TOKEN</p></blockquote><p>基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。</p><p>流程上是这样的：</p><ul><li>用户使用用户名密码来请求服务器</li><li>服务器进行验证用户的信息</li><li>服务器通过验证发送给用户一个token</li><li>客户端存储token，并在每次请求时附送上这个token值</li><li>服务端验证token值，并返回数据</li></ul><p>这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持<code>CORS(跨来源资源共享)</code>策略，一般我们在服务端这么做就可以了<code>Access-Control-Allow-Origin: *</code>。</p><h2 id="计网面试题" tabindex="-1"><a class="header-anchor" href="#计网面试题"><span>计网面试题</span></a></h2><h3 id="tcp和udp的区别-tcp靠什么保证可靠连接" tabindex="-1"><a class="header-anchor" href="#tcp和udp的区别-tcp靠什么保证可靠连接"><span>TCP和UDP的区别，TCP靠什么保证可靠连接？</span></a></h3><blockquote><p>TCP通过以下机制来保证可靠连接：</p><ol><li>序列号和确认应答：TCP将每个发送的数据包进行编号，接收方通过发送确认应答来确认已接收到的数据包。发送方根据确认应答确定是否需要重传丢失的数据包。</li><li>重传机制：如果发送方未收到确认应答或检测到数据包丢失，它会自动重传该数据包，确保数据的可靠传输。</li><li>滑动窗口：TCP使用滑动窗口机制来控制发送方发送的数据量，以适应网络的拥塞情况，保证发送速率与接收速率的匹配。</li><li>拥塞控制：TCP通过拥塞窗口和拥塞避免算法来控制发送速率，避免网络拥塞并保证整体性能。</li></ol></blockquote><h3 id="讲一下tcp三次握手-为什么要3次-两次或者四次不行吗" tabindex="-1"><a class="header-anchor" href="#讲一下tcp三次握手-为什么要3次-两次或者四次不行吗"><span>讲一下TCP三次握手 为什么要3次，两次或者四次不行吗</span></a></h3><p>TCP 建立连接时，通过三次握手能<strong>防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按序传输。</p><h2 id="base64" tabindex="-1"><a class="header-anchor" href="#base64"><span>Base64</span></a></h2><p>介绍：</p><ul><li>base64 - <mark>只是一种编码方法，并不是加密算法</mark> 所有的数据都是明文存储</li><li><strong>可以把任意的二进制（图片、视频、音频、字符串）转成可打印的字符</strong></li></ul><p>原理：</p><ul><li>由来 2^6=64位二进制，把所有字符串转成二进制然后每6位一个转成base64</li><li>编码后的长度要是4的倍数，不是则需最后补上一个等号</li></ul><h2 id="chrome-js" tabindex="-1"><a class="header-anchor" href="#chrome-js"><span>Chrome &amp; JS</span></a></h2><h3 id="f12-crul" tabindex="-1"><a class="header-anchor" href="#f12-crul"><span>F12-crul</span></a></h3><p>f12 右键一个请求 copy as cURL 可以得到一个 curl 命令集， Ant Work 中就是这样给我们接口信息，我们组数据做 QA 对语料喂给 GPT</p><h3 id="chrome-url" tabindex="-1"><a class="header-anchor" href="#chrome-url"><span>Chrome-Url</span></a></h3><blockquote><p>url地址栏区分大小写吗</p></blockquote><p>在大多数常见的浏览器中，URL地址栏通常是不区分大小写的。这意味着无论您输入的是大写字母、小写字母还是大小写混合，浏览器都会将其视为相同的URL。</p><p>例如，以下URL在地址栏中是等效的：</p><p>复制</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>http://www.example.com
HTTP://WWW.EXAMPLE.COM
http://www.Example.com
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不过需要注意的是，尽管地址栏不区分大小写，但是URL路径和查询参数部分可能会受到服务器的影响。某些服务器可能会对URL路径和查询参数进行区分大小写的处理。这意味着在特定的服务器环境中，<code>/path</code> 和 <code>/Path</code> 可能被视为不同的路径。</p><p>在Spring Boot中，默认情况下，<code>@GetMapping(&quot;/A&quot;)</code> 和 <code>@GetMapping(&quot;/a&quot;)</code> 是被视为两个不同的路径的。这是因为Spring Boot默认情况下是区分路径的大小写的。</p><p>所以，当您使用<code>@GetMapping(&quot;/A&quot;)</code>注解时，它将映射到路径<code>/A</code>，而<code>@GetMapping(&quot;/a&quot;)</code>将映射到路径<code>/a</code>。这两个路径被视为不同的URL。</p><p>如果您希望路径大小写不敏感，即<code>/A</code>和<code>/a</code>被视为相同的路径，可以在Spring Boot的配置中进行相应的设置。您可以在<code>application.properties</code>或<code>application.yml</code>文件中添加以下配置：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>spring.mvc.pathmatch.matching-strategy=ant_path_matcher
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>What does %2F mean in a URL? ASCII Encoding Reference</p></blockquote><p>场景：我用电脑识别 QR_Code 到 URL 浏览器 发现把里面的 <code>/</code> 全部转移成 <code>%2F</code> 了</p><p>联想到 <code>空格</code> 是 <code>%20</code> 于是系统总结下：</p><p>常见的需要转义的字符：https://www.w3schools.com/tags/ref_urlencode.ASP</p><p>在线 URLDecode 解码工具</p><h3 id="f12-js" tabindex="-1"><a class="header-anchor" href="#f12-js"><span>F12-JS</span></a></h3><blockquote><p>实用 JS 到 Console</p></blockquote><p>1）复制一个 input 的 Selector, <strong>我这里也有便捷方式，发现input有个 <code>readonly</code> 控制的不可编辑！！！把这个删了就行！~</strong></p><p>在 JavaScript 字符串中需要转义的特殊字符：</p><ul><li>反斜杠 <code>\\</code>: 反斜杠用于转义后面的字符，例如 <code>\\\\</code> 表示一个普通的反斜杠字符。</li><li>引号 <code>&quot;</code> 和 <code>&#39;</code>: 如果字符串本身包含引号，需要使用反斜杠进行转义，例如 <code>\\&quot;</code> 或 <code>\\&#39;</code>。</li><li>换行符 <code>\\n</code>: 表示换行。</li><li>回车符 <code>\\r</code>: 表示回车。</li><li>制表符 <code>\\t</code>: 表示水平制表符。</li></ul><figure><img src="http://images.zzq8.cn/img/image-20231120173938571.png" alt="image-20231120173938571" tabindex="0" loading="lazy"><figcaption>image-20231120173938571</figcaption></figure><p>2）js如何给td标签设置值</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">//tdElement 可以通过 getElementById / querySelector 获取</span>
tdElement<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">&#39;新的值&#39;</span><span class="token punctuation">;</span> <span class="token comment">// 设置 &lt;td&gt; 的内容</span>
tdElement<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token string">&#39;新的值&#39;</span><span class="token punctuation">;</span>
tdElement<span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">&#39;新的值&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="chrome-shortcutkey" tabindex="-1"><a class="header-anchor" href="#chrome-shortcutkey"><span>Chrome-ShortcutKey</span></a></h3>`,44),I={href:"https://support.google.com/chrome/answer/157179",target:"_blank",rel:"noopener noreferrer"},W=l(`<table><thead><tr><th style="text-align:left;">操作</th><th>快捷键</th></tr></thead><tbody><tr><td style="text-align:left;">为网站名称添加 <code>www.</code> 和 <code>.com</code>，然后在当前标签页中打开该网址</td><td>输入网站名称并按 <strong>Ctrl + Enter</strong> 键</td></tr><tr><td style="text-align:left;">打开新的标签页并执行 Google 搜索</td><td>输入搜索字词并按 Alt + Enter 键</td></tr><tr><td style="text-align:left;">跳转到地址栏</td><td><strong>Ctrl + l</strong> 或 Alt + d 或 F6</td></tr></tbody></table><ul><li><p>shift+esc 任务管理器</p></li><li><p><strong>ctrl+shift+delete 清缓存必备</strong></p></li><li><p>F12 == ctrl+shift+i</p></li></ul><blockquote><p>搜索技巧</p></blockquote><p>只搜索某个站点： 空格域名</p><p>排除某个站点： 空格 -域名</p><h3 id="html-刷新" tabindex="-1"><a class="header-anchor" href="#html-刷新"><span>HTML 刷新</span></a></h3><p>让网页多长时间（秒）刷新自己，或在多长时间后让网页自动链接到其它网页。</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;1;url=http://www.baidu.com/&quot;&gt;
or
&lt;body onload=&quot;parent.location=&#39;http://www.baidu.com&#39;&quot;&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="curl" tabindex="-1"><a class="header-anchor" href="#curl"><span>Curl</span></a></h2><blockquote><p>https://www.ruanyifeng.com/blog/2019/09/curl-reference.html</p></blockquote><p>curl -XPOST localhost:8888/user -d &#39;id=42&#39; -d &#39;name=Tom&#39; (POST学习！！)</p><p>curl -XPOST localhost:8888/user -H &#39;Content-Type:application/json&#39; -d &#39;{&quot;id&quot;:42, &quot;name&quot;:&quot;Tom&quot;}&#39;</p><ul><li>使用-d参数以后，HTTP 请求会自动加上标头Content-Type : application/x-www-form-urlencoded。并且会自动将请求转为 POST 方法，因此可以省略-X POST。</li></ul>`,13);function D(O,J){const n=i("ExternalLinkIcon"),a=i("center"),r=i("font");return p(),d("div",null,[h,e("p",null,[e("a",m,[t("http 请求包含哪几个部分（请求行、请求头、请求体）"),o(n)])]),g,e("ul",null,[k,e("li",null,[e("p",null,[e("a",q,[t("DNT"),o(n)]),t(": 1 （"),b,t("o "),_,t("ot "),v,t("rack）")]),x]),f]),e("h2",C,[e("a",T,[e("span",null,[e("a",S,[t("三、Response Headers（响应头）"),o(n)])])])]),R,o(a,null,{default:s(()=>[t("---扩展知识---")]),_:1}),e("h2",w,[e("a",y,[e("span",null,[t("四、"),e("a",H,[t("XHR "),o(n)])])])]),P,e("ul",null,[e("li",null,[A,t(": 每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，"),o(r,{color:"red"},{default:s(()=>[t("通常而言session都是保存在内存")]),_:1}),t("中，而随着"),E,t("。")]),L,M]),z,N,j,e("h2",U,[e("a",F,[e("span",null,[e("a",G,[t("Cookie"),o(n)])])])]),B,e("blockquote",null,[e("p",null,[e("a",I,[t("Chrome 官网快捷键总结"),o(n)])])]),W])}const V=c(u,[["render",D],["__file","HttpRequest.html.vue"]]),Z=JSON.parse('{"path":"/studynotes/408-Network/HttpRequest.html","title":"HttpRequest","lang":"zh-CN","frontmatter":{"description":"HttpRequest http 请求包含哪几个部分（请求行、请求头、请求体） 这里放一些常见的，具体的去搜 一、General（请求行） Request URL: http://127.0.0.1:8848/nacos/ Request Method: GET Status Code:304（响应状态码） Remote Address: 127.0....","head":[["meta",{"property":"og:url","content":"https://doc.zzq8.cn/studynotes/408-Network/HttpRequest.html"}],["meta",{"property":"og:site_name","content":"Zz"}],["meta",{"property":"og:title","content":"HttpRequest"}],["meta",{"property":"og:description","content":"HttpRequest http 请求包含哪几个部分（请求行、请求头、请求体） 这里放一些常见的，具体的去搜 一、General（请求行） Request URL: http://127.0.0.1:8848/nacos/ Request Method: GET Status Code:304（响应状态码） Remote Address: 127.0...."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"http://images.zzq8.cn/img/image-20231120173938571.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-15T14:45:27.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-15T14:45:27.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"HttpRequest\\",\\"image\\":[\\"http://images.zzq8.cn/img/image-20231120173938571.png\\"],\\"dateModified\\":\\"2024-05-15T14:45:27.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"一、General（请求行）","slug":"一、general-请求行","link":"#一、general-请求行","children":[]},{"level":2,"title":"二、Request Headers（请求头）","slug":"二、request-headers-请求头","link":"#二、request-headers-请求头","children":[]},{"level":2,"title":"三、Response Headers（响应头）","slug":"三、response-headers-响应头","link":"#三、response-headers-响应头","children":[]},{"level":2,"title":"四、XHR","slug":"四、xhr","link":"#四、xhr","children":[]},{"level":2,"title":"Session 缺点","slug":"session-缺点","link":"#session-缺点","children":[{"level":3,"title":"为什么要使用Session技术？","slug":"为什么要使用session技术","link":"#为什么要使用session技术","children":[]},{"level":3,"title":"Sessin 缺点：","slug":"sessin-缺点","link":"#sessin-缺点","children":[]}]},{"level":2,"title":"Cookie","slug":"cookie","link":"#cookie","children":[]},{"level":2,"title":"token","slug":"token","link":"#token","children":[]},{"level":2,"title":"计网面试题","slug":"计网面试题","link":"#计网面试题","children":[{"level":3,"title":"TCP和UDP的区别，TCP靠什么保证可靠连接？","slug":"tcp和udp的区别-tcp靠什么保证可靠连接","link":"#tcp和udp的区别-tcp靠什么保证可靠连接","children":[]},{"level":3,"title":"讲一下TCP三次握手 为什么要3次，两次或者四次不行吗","slug":"讲一下tcp三次握手-为什么要3次-两次或者四次不行吗","link":"#讲一下tcp三次握手-为什么要3次-两次或者四次不行吗","children":[]}]},{"level":2,"title":"Base64","slug":"base64","link":"#base64","children":[]},{"level":2,"title":"Chrome & JS","slug":"chrome-js","link":"#chrome-js","children":[{"level":3,"title":"F12-crul","slug":"f12-crul","link":"#f12-crul","children":[]},{"level":3,"title":"Chrome-Url","slug":"chrome-url","link":"#chrome-url","children":[]},{"level":3,"title":"F12-JS","slug":"f12-js","link":"#f12-js","children":[]},{"level":3,"title":"Chrome-ShortcutKey","slug":"chrome-shortcutkey","link":"#chrome-shortcutkey","children":[]},{"level":3,"title":"HTML 刷新","slug":"html-刷新","link":"#html-刷新","children":[]}]},{"level":2,"title":"Curl","slug":"curl","link":"#curl","children":[]}],"git":{"createdTime":1712997543000,"updatedTime":1715784327000,"contributors":[{"name":"Fighting","email":"1024zzq@gmail.com","commits":3},{"name":"MiniPC","email":"1024zzq@gmail.com","commits":1}]},"readingTime":{"minutes":12.86,"words":3857},"filePathRelative":"studynotes/408-Network/HttpRequest.md","localizedDate":"2024年4月13日","autoDesc":true}');export{V as comp,Z as data};
