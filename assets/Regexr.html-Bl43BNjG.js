import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as a,a as e}from"./app-CkI1xZQC.js";const n={},t=e(`<h1 id="regular-expression" tabindex="-1"><a class="header-anchor" href="#regular-expression"><span><a href="https://regexr-cn.com/" target="_blank" rel="noopener noreferrer">Regular Expression</a></span></a></h1><blockquote><p>正则很多地方都可以用，各类文本编辑器！处理文本等工作效率 up XD：受益匪浅，就在title网站去学！！！</p></blockquote><h1 id="一、日常问题" tabindex="-1"><a class="header-anchor" href="#一、日常问题"><span>一、日常问题</span></a></h1><h2 id="_1-匹配空行" tabindex="-1"><a class="header-anchor" href="#_1-匹配空行"><span>1.匹配空行</span></a></h2><blockquote><p><code>^\\s*$</code> （* 指空格出现 0 次或多次）-&gt; * 匹配0个或更多前面的标记。</p></blockquote><p>1）除了常使用 ^ 另外 $ 也可以熟练用起来</p><p>2）正则匹配0次必须加星</p><h2 id="_2-使用错误" tabindex="-1"><a class="header-anchor" href="#_2-使用错误"><span>2.* / + 使用错误</span></a></h2><blockquote><p>做 LeetCode 发现</p></blockquote><p>&quot;the sky is blue&quot;.split(&quot;\\s*&quot;); //以 Char 为单位</p><ul><li>警告:表达式可以返回空匹配项，也可以匹配 在某些用例中是无限的。 有15个字符没有找到匹配项，包括14个空匹配项(*不显示)。 插入点:第0行，col 15，索引15</li></ul><p>&quot;the sky is blue&quot;.split(&quot;\\s+&quot;); //以 Word 为单位</p><h2 id="非集" tabindex="-1"><a class="header-anchor" href="#非集"><span>&gt; 非集</span></a></h2><blockquote><p>匹配不在集合中的任何字符。</p><p>场景：我匹每行开头不是 a 的 <code>^[^a]</code></p></blockquote><h2 id="capturing-group" tabindex="-1"><a class="header-anchor" href="#capturing-group"><span>&gt; capturing group</span></a></h2><blockquote><p>场景：sublime中 我个人频繁用到，替换东西时候又得带上原先的。。。$1..$n 可以复用 find 里被()包裹的组</p><p>把多个标记分在同一组并创建一个捕获分组，用来创建子串或引用。</p></blockquote><p>Target - <em>hahaha</em> <em>ha</em>a <em>ha</em>h!</p><p>Find：(ha)+</p><p>Replace：$1</p><p>突然发现 Java 正则也可以用复用这个组的概念：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">[] args) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        String</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> input </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &quot;#0:%洪都%;#1:%洪都%;#2:%洪都%;#3:0;#4:150;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        // 定义正则表达式匹配模式</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        String</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> regex </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &quot;#</span><span style="--shiki-light:#005CC5;--shiki-dark:#56B6C2;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">d+:(.*?);&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        // 创建 Pattern 对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        Pattern</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> pattern </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Pattern</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">compile</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(regex);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        // 创建 Matcher 对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        Matcher</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> matcher </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> pattern</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">matcher</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(input);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        // 创建集合存储提取的结果</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        List</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> partsList </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> ArrayList</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        // 迭代匹配结果并提取部分内容</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">matcher</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">find</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">            String</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> part </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> matcher</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">group</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">            partsList</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(part);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        // 打印提取的结果</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> part </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> partsList) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">            System</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;提取的部分内容: &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> part);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="lzay" tabindex="-1"><a class="header-anchor" href="#lzay"><span>&gt; lzay(?)</span></a></h2><blockquote><p>场景：[\\s\\S]*? World xxxxxWorld，这样只会匹配到前面</p><p>令前面的标记变慵懒，让其尽可能少地匹配字符。默认情况下，量词是贪婪的会尽可能多地匹配字符。</p></blockquote><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>b\\w+?</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>b *be* *be*e *be*er *be*ers</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="positive-lookahead-negative-lookahead" tabindex="-1"><a class="header-anchor" href="#positive-lookahead-negative-lookahead"><span><mark>&gt; positive lookahead / negative lookahead</mark></span></a></h2><blockquote><p>匹配主表达式后面的组而不将其包含在结果中。 (?=ABC)</p><p>指定主表达式后无法匹配的组（如果匹配，则结果将被丢弃）。(?!ABC)</p><blockquote><p>2024 再次使用，<mark>目的 -&gt; 匹配最小长度满足条件的值</mark></p><p>错误使用：<code>&lt;DataBinding[\\S\\s]*?ColumnKey=&quot;StartBusinessDate&quot;</code></p><p>文本：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>&lt;DataBinding</span></span>
<span class="line"><span>asdasd</span></span>
<span class="line"><span>&lt;DataBinding TableKey=&quot;DepositCollectHead&quot; ColumnKey=&quot;StartBusinessDate&quot;/&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要改为：<code>&lt;DataBinding(?:(?!&lt;\\/DataBinding&gt;).)*?ColumnKey=&quot;StartBusinessDate&quot;\\/&gt;</code> //也是错的！不知道怎么处理</p><p>----------------还未理解透彻</p><h2 id="自己再研究" tabindex="-1"><a class="header-anchor" href="#自己再研究"><span>自己再研究</span></a></h2><p>发现：<code>&lt;DataBinding(.*)ColumnKey=&quot;StartBusinessDate&quot;\\/&gt;</code> 就行</p><p>其实就是区分 [\\S\\s]* 和 .* 的区分！！！！ <mark>前者包括换行符，后者不包只匹一行</mark></p><p>如果需要匹配跨行文本或保留换行符，则使用 &quot;[\\S\\s]<em>&quot; 可能更合适。而当只需匹配单行文本时，使用 &quot;.</em>&quot; 可能更简洁和直观。</p></blockquote></blockquote><p>(?=ABC)</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>\\d(?=px)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><p>1pt <code>2</code>px 3em <code>4</code>px</p><p>(?!ABC)</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>\\d(?!px)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><p><code>1</code>pt 2px <code>3</code>em 4px</p><h2 id="other" tabindex="-1"><a class="header-anchor" href="#other"><span>Other</span></a></h2><ul><li><p>/：代表正则表达式的头和尾，所以很多时候需要转义再用</p></li><li><p>其实就是区分 [\\S\\s]* 和 .* 的区分！！！！ <mark>前者包括换行符，后者不包只匹一行</mark> 【看上面场景案例(?=ABC)】</p><p>如果需要匹配跨行文本或保留换行符，则使用 &quot;[\\S\\s]<em>&quot; 可能更合适。而当只需匹配单行文本时，使用 &quot;.</em>&quot; 可能更简洁和直观。</p></li></ul>`,38),l=[t];function h(p,r){return a(),s("div",null,l)}const o=i(n,[["render",h],["__file","Regexr.html.vue"]]),c=JSON.parse('{"path":"/studynotes/ZOther/Regexr.html","title":"Regular Expression","lang":"zh-CN","frontmatter":{"description":"Regular Expression 正则很多地方都可以用，各类文本编辑器！处理文本等工作效率 up XD：受益匪浅，就在title网站去学！！！ 一、日常问题 1.匹配空行 ^\\\\s*$ （* 指空格出现 0 次或多次）-> * 匹配0个或更多前面的标记。 1）除了常使用 ^ 另外 $ 也可以熟练用起来 2）正则匹配0次必须加星 2.* / + 使用错...","head":[["meta",{"property":"og:url","content":"https://doc.zzq8.cn/studynotes/ZOther/Regexr.html"}],["meta",{"property":"og:site_name","content":"Piglet"}],["meta",{"property":"og:title","content":"Regular Expression"}],["meta",{"property":"og:description","content":"Regular Expression 正则很多地方都可以用，各类文本编辑器！处理文本等工作效率 up XD：受益匪浅，就在title网站去学！！！ 一、日常问题 1.匹配空行 ^\\\\s*$ （* 指空格出现 0 次或多次）-> * 匹配0个或更多前面的标记。 1）除了常使用 ^ 另外 $ 也可以熟练用起来 2）正则匹配0次必须加星 2.* / + 使用错..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-13T08:39:03.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-13T08:39:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Regular Expression\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-13T08:39:03.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"1.匹配空行","slug":"_1-匹配空行","link":"#_1-匹配空行","children":[]},{"level":2,"title":"2.* / + 使用错误","slug":"_2-使用错误","link":"#_2-使用错误","children":[]},{"level":2,"title":"> 非集","slug":"非集","link":"#非集","children":[]},{"level":2,"title":"> capturing group","slug":"capturing-group","link":"#capturing-group","children":[]},{"level":2,"title":"> lzay(?)","slug":"lzay","link":"#lzay","children":[]},{"level":2,"title":"> positive lookahead / negative lookahead","slug":"positive-lookahead-negative-lookahead","link":"#positive-lookahead-negative-lookahead","children":[]},{"level":2,"title":"Other","slug":"other","link":"#other","children":[]}],"git":{"createdTime":1712997543000,"updatedTime":1712997543000,"contributors":[{"name":"Fighting","email":"1024zzq@gmail.com","commits":1}]},"readingTime":{"minutes":2.81,"words":842},"filePathRelative":"studynotes/ZOther/Regexr.md","localizedDate":"2024年4月13日","autoDesc":true}');export{o as comp,c as data};
